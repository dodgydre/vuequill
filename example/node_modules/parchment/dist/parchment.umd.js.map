{"version":3,"file":"parchment.umd.js","sources":["../src/scope.ts","../src/attributor/attributor.ts","../src/error.ts","../src/registry.ts","../src/attributor/class.ts","../src/attributor/style.ts","../src/attributor/store.ts","../src/blot/abstract/shadow.ts","../src/blot/abstract/leaf.ts","../src/collection/linked-list.ts","../src/blot/abstract/parent.ts","../src/blot/inline.ts","../src/blot/block.ts","../src/blot/abstract/container.ts","../src/blot/embed.ts","../src/blot/scroll.ts","../src/blot/text.ts"],"sourcesContent":["enum Scope {\n  TYPE = (1 << 2) - 1, // 0011 Lower two bits\n  LEVEL = ((1 << 2) - 1) << 2, // 1100 Higher two bits\n\n  ATTRIBUTE = (1 << 0) | LEVEL, // 1101\n  BLOT = (1 << 1) | LEVEL, // 1110\n  INLINE = (1 << 2) | TYPE, // 0111\n  BLOCK = (1 << 3) | TYPE, // 1011\n\n  BLOCK_BLOT = BLOCK & BLOT, // 1010\n  INLINE_BLOT = INLINE & BLOT, // 0110\n  BLOCK_ATTRIBUTE = BLOCK & ATTRIBUTE, // 1001\n  INLINE_ATTRIBUTE = INLINE & ATTRIBUTE, // 0101\n\n  ANY = TYPE | LEVEL,\n}\n\nexport default Scope;\n","import Scope from '../scope';\n\nexport interface AttributorOptions {\n  scope?: Scope;\n  whitelist?: string[];\n}\n\nexport default class Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return Array.from(node.attributes).map((item: Attr) => item.name);\n  }\n\n  public scope: Scope;\n  public whitelist: string[] | undefined;\n\n  constructor(\n    public readonly attrName: string,\n    public readonly keyName: string,\n    options: AttributorOptions = {},\n  ) {\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope =\n      options.scope != null\n        ? // Ignore type bits, force attribute bit\n          (options.scope & Scope.LEVEL) | attributeBit\n        : Scope.ATTRIBUTE;\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    node.setAttribute(this.keyName, value);\n    return true;\n  }\n\n  public canAdd(_node: HTMLElement, value: any): boolean {\n    if (this.whitelist == null) {\n      return true;\n    }\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  }\n\n  public remove(node: HTMLElement): void {\n    node.removeAttribute(this.keyName);\n  }\n\n  public value(node: HTMLElement): any {\n    const value = node.getAttribute(this.keyName);\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n    return '';\n  }\n}\n","export default class ParchmentError extends Error {\n  public message: string;\n  public name: string;\n  public stack!: string;\n\n  constructor(message: string) {\n    message = '[Parchment] ' + message;\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n}\n","import Attributor from './attributor/attributor';\nimport {\n  type Blot,\n  type BlotConstructor,\n  type Root,\n} from './blot/abstract/blot';\nimport ParchmentError from './error';\nimport Scope from './scope';\n\nexport type RegistryDefinition = Attributor | BlotConstructor;\n\nexport interface RegistryInterface {\n  create(scroll: Root, input: Node | string | Scope, value?: any): Blot;\n  query(query: string | Node | Scope, scope: Scope): RegistryDefinition | null;\n  register(...definitions: any[]): any;\n}\n\nexport default class Registry implements RegistryInterface {\n  public static blots = new WeakMap<Node, Blot>();\n\n  public static find(node?: Node | null, bubble = false): Blot | null {\n    if (node == null) {\n      return null;\n    }\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n    if (bubble) {\n      let parentNode: Node | null = null;\n      try {\n        parentNode = node.parentNode;\n      } catch (err) {\n        // Probably hit a permission denied error.\n        // A known case is in Firefox, event targets can be anonymous DIVs\n        // inside an input element.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n\n  private attributes: { [key: string]: Attributor } = {};\n  private classes: { [key: string]: BlotConstructor } = {};\n  private tags: { [key: string]: BlotConstructor } = {};\n  private types: { [key: string]: RegistryDefinition } = {};\n\n  public create(scroll: Root, input: Node | string | Scope, value?: any): Blot {\n    const match = this.query(input);\n    if (match == null) {\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    }\n    const blotClass = match as BlotConstructor;\n    const node =\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE\n        ? input\n        : blotClass.create(value);\n\n    const blot = new blotClass(scroll, node as Node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    return Registry.find(node, bubble);\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    let match;\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query];\n      // @ts-expect-error Fix me later\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & Scope.LEVEL & Scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & Scope.LEVEL & Scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof Element) {\n      const names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some((name) => {\n        match = this.classes[name];\n        if (match) {\n          return true;\n        }\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n    if (match == null) {\n      return null;\n    }\n    if (\n      'scope' in match &&\n      scope & Scope.LEVEL & match.scope &&\n      scope & Scope.TYPE & match.scope\n    ) {\n      return match;\n    }\n    return null;\n  }\n\n  public register(...definitions: RegistryDefinition[]): RegistryDefinition[] {\n    return definitions.map((definition) => {\n      const isBlot = 'blotName' in definition;\n      const isAttr = 'attrName' in definition;\n      if (!isBlot && !isAttr) {\n        throw new ParchmentError('Invalid definition');\n      } else if (isBlot && definition.blotName === 'abstract') {\n        throw new ParchmentError('Cannot register abstract class');\n      }\n      const key = isBlot\n        ? definition.blotName\n        : isAttr\n        ? definition.attrName\n        : (undefined as never); // already handled by above checks\n      this.types[key] = definition;\n\n      if (isAttr) {\n        if (typeof definition.keyName === 'string') {\n          this.attributes[definition.keyName] = definition;\n        }\n      } else if (isBlot) {\n        if (definition.className) {\n          this.classes[definition.className] = definition;\n        }\n        if (definition.tagName) {\n          if (Array.isArray(definition.tagName)) {\n            definition.tagName = definition.tagName.map((tagName: string) => {\n              return tagName.toUpperCase();\n            });\n          } else {\n            definition.tagName = definition.tagName.toUpperCase();\n          }\n          const tagNames = Array.isArray(definition.tagName)\n            ? definition.tagName\n            : [definition.tagName];\n          tagNames.forEach((tag: string) => {\n            if (this.tags[tag] == null || definition.className == null) {\n              this.tags[tag] = definition;\n            }\n          });\n        }\n      }\n      return definition;\n    });\n  }\n}\n","import Attributor from './attributor';\n\nfunction match(node: HTMLElement, prefix: string): string[] {\n  const className = node.getAttribute('class') || '';\n  return className\n    .split(/\\s+/)\n    .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\n\nclass ClassAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('class') || '')\n      .split(/\\s+/)\n      .map((name) => name.split('-').slice(0, -1).join('-'));\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    this.remove(node);\n    node.classList.add(`${this.keyName}-${value}`);\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    const matches = match(node, this.keyName);\n    matches.forEach((name) => {\n      node.classList.remove(name);\n    });\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    const result = match(node, this.keyName)[0] || '';\n    const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default ClassAttributor;\n","import Attributor from './attributor';\n\nfunction camelize(name: string): string {\n  const parts = name.split('-');\n  const rest = parts\n    .slice(1)\n    .map((part: string) => part[0].toUpperCase() + part.slice(1))\n    .join('');\n  return parts[0] + rest;\n}\n\nclass StyleAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('style') || '').split(';').map((value) => {\n      const arr = value.split(':');\n      return arr[0].trim();\n    });\n  }\n\n  public add(node: HTMLElement, value: any): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    // @ts-expect-error Fix me later\n    node.style[camelize(this.keyName)] = '';\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  }\n\n  public value(node: HTMLElement): any {\n    // @ts-expect-error Fix me later\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default StyleAttributor;\n","import type { Formattable } from '../blot/abstract/blot';\nimport Registry from '../registry';\nimport Scope from '../scope';\nimport Attributor from './attributor';\nimport ClassAttributor from './class';\nimport StyleAttributor from './style';\n\nclass AttributorStore {\n  private attributes: { [key: string]: Attributor } = {};\n  private domNode: HTMLElement;\n\n  constructor(domNode: HTMLElement) {\n    this.domNode = domNode;\n    this.build();\n  }\n\n  public attribute(attribute: Attributor, value: any): void {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  }\n\n  public build(): void {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) {\n      return;\n    }\n    const attributes = Attributor.keys(this.domNode);\n    const classes = ClassAttributor.keys(this.domNode);\n    const styles = StyleAttributor.keys(this.domNode);\n    attributes\n      .concat(classes)\n      .concat(styles)\n      .forEach((name) => {\n        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        if (attr instanceof Attributor) {\n          this.attributes[attr.attrName] = attr;\n        }\n      });\n  }\n\n  public copy(target: Formattable): void {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n\n  public move(target: Formattable): void {\n    this.copy(target);\n    Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    });\n    this.attributes = {};\n  }\n\n  public values(): { [key: string]: any } {\n    return Object.keys(this.attributes).reduce(\n      (attributes: { [key: string]: any }, name: string) => {\n        attributes[name] = this.attributes[name].value(this.domNode);\n        return attributes;\n      },\n      {},\n    );\n  }\n}\n\nexport default AttributorStore;\n","import ParchmentError from '../../error';\nimport Registry from '../../registry';\nimport Scope from '../../scope';\nimport type { Blot, BlotConstructor, Formattable, Parent, Root } from './blot';\n\nclass ShadowBlot implements Blot {\n  public static blotName = 'abstract';\n  public static className: string;\n  public static requiredContainer: BlotConstructor;\n  public static scope: Scope;\n  public static tagName: string | string[];\n\n  public static create(rawValue?: unknown): Node {\n    if (this.tagName == null) {\n      throw new ParchmentError('Blot definition missing tagName');\n    }\n    let node: HTMLElement;\n    let value: string | number | undefined;\n    if (Array.isArray(this.tagName)) {\n      if (typeof rawValue === 'string') {\n        value = rawValue.toUpperCase();\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      } else if (typeof rawValue === 'number') {\n        value = rawValue;\n      }\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (value && this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  public prev: Blot | null;\n  public next: Blot | null;\n  // @ts-expect-error Fix me later\n  public parent: Parent;\n\n  // Hack for accessing inherited static methods\n  get statics(): any {\n    return this.constructor;\n  }\n  constructor(\n    public scroll: Root,\n    public domNode: Node,\n  ) {\n    Registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  public attach(): void {\n    // Nothing to do\n  }\n\n  public clone(): Blot {\n    const domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  }\n\n  public detach(): void {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n    Registry.blots.delete(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    const blot = this.isolate(index, length);\n    blot.remove();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope) as Parent &\n        Formattable;\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const blot =\n      def == null\n        ? this.scroll.create('text', value)\n        : this.scroll.create(value, def);\n    const ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  }\n\n  public isolate(index: number, length: number): Blot {\n    const target = this.split(index);\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n    target.split(length);\n    return target;\n  }\n\n  public length(): number {\n    return 1;\n  }\n\n  public offset(root: Blot = this.parent): number {\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  }\n\n  public optimize(_context?: { [key: string]: any }): void {\n    if (\n      this.statics.requiredContainer &&\n      !(this.parent instanceof this.statics.requiredContainer)\n    ) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  }\n\n  public remove(): void {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n    this.detach();\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n    return replacement;\n  }\n\n  public split(index: number, _force?: boolean): Blot | null {\n    return index === 0 ? this : this.next;\n  }\n\n  public update(\n    _mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    // Nothing to do by default\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper =\n      typeof name === 'string'\n        ? (this.scroll.create(name, value) as Parent)\n        : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    }\n    wrapper.appendChild(this);\n    return wrapper;\n  }\n}\n\nexport default ShadowBlot;\n","import Scope from '../../scope';\nimport type { Leaf } from './blot';\nimport ShadowBlot from './shadow';\n\nclass LeafBlot extends ShadowBlot implements Leaf {\n  public static scope = Scope.INLINE_BLOT;\n\n  public static value(_domNode: Node): any {\n    return true;\n  }\n\n  public index(node: Node, offset: number): number {\n    if (\n      this.domNode === node ||\n      this.domNode.compareDocumentPosition(node) &\n        Node.DOCUMENT_POSITION_CONTAINED_BY\n    ) {\n      return Math.min(offset, 1);\n    }\n    return -1;\n  }\n\n  public position(index: number, _inclusive?: boolean): [Node, number] {\n    const childNodes: Node[] = Array.from(this.parent.domNode.childNodes);\n    let offset = childNodes.indexOf(this.domNode);\n    if (index > 0) {\n      offset += 1;\n    }\n    return [this.parent.domNode, offset];\n  }\n\n  public value(): any {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || true,\n    };\n  }\n}\n\nexport default LeafBlot;\n","import type LinkedNode from './linked-node';\n\nclass LinkedList<T extends LinkedNode> {\n  public head: T | null;\n  public tail: T | null;\n  public length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public append(...nodes: T[]): void {\n    this.insertBefore(nodes[0], null);\n    if (nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n\n  public at(index: number): T | null {\n    const next = this.iterator();\n    let cur = next();\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n    return cur;\n  }\n\n  public contains(node: T): boolean {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n      cur = next();\n    }\n    return false;\n  }\n\n  public indexOf(node: T): number {\n    const next = this.iterator();\n    let cur = next();\n    let index = 0;\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n      index += 1;\n      cur = next();\n    }\n    return -1;\n  }\n\n  public insertBefore(node: T | null, refNode: T | null): void {\n    if (node == null) {\n      return;\n    }\n    this.remove(node);\n    node.next = refNode;\n    if (refNode != null) {\n      node.prev = refNode.prev;\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n      refNode.prev = node;\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n    this.length += 1;\n  }\n\n  public offset(target: T): number {\n    let index = 0;\n    let cur = this.head;\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n      index += cur.length();\n      cur = cur.next as T;\n    }\n    return -1;\n  }\n\n  public remove(node: T): void {\n    if (!this.contains(node)) {\n      return;\n    }\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    if (node === this.head) {\n      this.head = node.next as T;\n    }\n    if (node === this.tail) {\n      this.tail = node.prev as T;\n    }\n    this.length -= 1;\n  }\n\n  public iterator(curNode: T | null = this.head): () => T | null {\n    // TODO use yield when we can\n    return (): T | null => {\n      const ret = curNode;\n      if (curNode != null) {\n        curNode = curNode.next as T;\n      }\n      return ret;\n    };\n  }\n\n  public find(index: number, inclusive = false): [T | null, number] {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      const length = cur.length();\n      if (\n        index < length ||\n        (inclusive &&\n          index === length &&\n          (cur.next == null || cur.next.length() !== 0))\n      ) {\n        return [cur, index];\n      }\n      index -= length;\n      cur = next();\n    }\n    return [null, 0];\n  }\n\n  public forEach(callback: (cur: T) => void): void {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  }\n\n  public forEachAt(\n    index: number,\n    length: number,\n    callback: (cur: T, offset: number, length: number) => void,\n  ): void {\n    if (length <= 0) {\n      return;\n    }\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    while (cur && curIndex < index + length) {\n      const curLength = cur.length();\n      if (index > curIndex) {\n        callback(\n          cur,\n          index - curIndex,\n          Math.min(length, curIndex + curLength - index),\n        );\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n      curIndex += curLength;\n      cur = next();\n    }\n  }\n\n  public map(callback: (cur: T) => any): any[] {\n    return this.reduce((memo: T[], cur: T) => {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  }\n\n  public reduce<M>(callback: (memo: M, cur: T) => M, memo: M): M {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n    return memo;\n  }\n}\n\nexport default LinkedList;\n","import LinkedList from '../../collection/linked-list';\nimport ParchmentError from '../../error';\nimport Scope from '../../scope';\nimport type { Blot, BlotConstructor, Parent, Root } from './blot';\nimport ShadowBlot from './shadow';\n\nfunction makeAttachedBlot(node: Node, scroll: Root): Blot {\n  const found = scroll.find(node);\n  if (found) return found;\n  try {\n    return scroll.create(node);\n  } catch (e) {\n    const blot = scroll.create(Scope.INLINE);\n    Array.from(node.childNodes).forEach((child: Node) => {\n      blot.domNode.appendChild(child);\n    });\n    if (node.parentNode) {\n      node.parentNode.replaceChild(blot.domNode, node);\n    }\n    blot.attach();\n    return blot;\n  }\n}\n\nclass ParentBlot extends ShadowBlot implements Parent {\n  public static allowedChildren: BlotConstructor[] | null;\n  public static defaultChild?: BlotConstructor;\n  public static uiClass = '';\n\n  public children!: LinkedList<Blot>;\n  public domNode!: HTMLElement;\n  public uiNode: HTMLElement | null = null;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.build();\n  }\n\n  public appendChild(other: Blot): void {\n    this.insertBefore(other);\n  }\n\n  public attach(): void {\n    super.attach();\n    this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n\n  public attachUI(node: HTMLElement): void {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n    this.uiNode = node;\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n\n  public build(): void {\n    this.children = new LinkedList<Blot>();\n    // Need to be reversed for if DOM nodes already in order\n    Array.from(this.domNode.childNodes)\n      .filter((node: Node) => node !== this.uiNode)\n      .reverse()\n      .forEach((node: Node) => {\n        try {\n          const child = makeAttachedBlot(node, this.scroll);\n          this.insertBefore(child, this.children.head || undefined);\n        } catch (err) {\n          if (err instanceof ParchmentError) {\n            return;\n          } else {\n            throw err;\n          }\n        }\n      });\n  }\n\n  public deleteAt(index: number, length: number): void {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n\n  public descendant<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index: number,\n  ): [T | null, number];\n  public descendant(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(criteria: any, index = 0): [Blot | null, number] {\n    const [child, offset] = this.children.find(index);\n    if (\n      (criteria.blotName == null && criteria(child)) ||\n      (criteria.blotName != null && child instanceof criteria)\n    ) {\n      return [child as any, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  }\n\n  public descendants<T extends Blot>(\n    criteria: new (...args: any[]) => T,\n    index?: number,\n    length?: number,\n  ): T[];\n  public descendants(\n    criteria: (blot: Blot) => boolean,\n    index?: number,\n    length?: number,\n  ): Blot[];\n  public descendants(\n    criteria: any,\n    index = 0,\n    length: number = Number.MAX_VALUE,\n  ): Blot[] {\n    let descendants: Blot[] = [];\n    let lengthLeft = length;\n    this.children.forEachAt(\n      index,\n      length,\n      (child: Blot, childIndex: number, childLength: number) => {\n        if (\n          (criteria.blotName == null && criteria(child)) ||\n          (criteria.blotName != null && child instanceof criteria)\n        ) {\n          descendants.push(child);\n        }\n        if (child instanceof ParentBlot) {\n          descendants = descendants.concat(\n            child.descendants(criteria, childIndex, lengthLeft),\n          );\n        }\n        lengthLeft -= childLength;\n      },\n    );\n    return descendants;\n  }\n\n  public detach(): void {\n    this.children.forEach((child) => {\n      child.detach();\n    });\n    super.detach();\n  }\n\n  public enforceAllowedChildren(): void {\n    let done = false;\n    this.children.forEach((child: Blot) => {\n      if (done) {\n        return;\n      }\n      const allowed = this.statics.allowedChildren.some(\n        (def: BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          this.splitAfter(child);\n        }\n        if (child.prev != null) {\n          this.splitAfter(child.prev);\n        }\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const [child, offset] = this.children.find(index);\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      const blot =\n        def == null\n          ? this.scroll.create('text', value)\n          : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n\n  public insertBefore(childBlot: Blot, refBlot?: Blot | null): void {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n    let refDomNode: Node | null = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n    if (\n      this.domNode.parentNode !== childBlot.domNode ||\n      this.domNode.nextSibling !== refDomNode\n    ) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n    childBlot.attach();\n  }\n\n  public length(): number {\n    return this.children.reduce((memo, child) => {\n      return memo + child.length();\n    }, 0);\n  }\n\n  public moveChildren(targetParent: Parent, refNode?: Blot): void {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n\n  public optimize(context?: { [key: string]: any }): void {\n    super.optimize(context);\n    this.enforceAllowedChildren();\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n        // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  }\n\n  public path(index: number, inclusive = false): [Blot, number][] {\n    const [child, offset] = this.children.find(index, inclusive);\n    const position: [Blot, number][] = [[this, index]];\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n    return position;\n  }\n\n  public removeChild(child: Blot): void {\n    this.children.remove(child);\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n    return super.replaceWith(replacement);\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.clone() as ParentBlot;\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  }\n\n  public splitAfter(child: Blot): Parent {\n    const after = this.clone() as ParentBlot;\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    return after;\n  }\n\n  public unwrap(): void {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n    this.remove();\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    const addedNodes: Node[] = [];\n    const removedNodes: Node[] = [];\n    mutations.forEach((mutation) => {\n      if (mutation.target === this.domNode && mutation.type === 'childList') {\n        addedNodes.push(...mutation.addedNodes);\n        removedNodes.push(...mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach((node: Node) => {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (\n        node.parentNode != null &&\n        // @ts-expect-error Fix me later\n        node.tagName !== 'IFRAME' &&\n        document.body.compareDocumentPosition(node) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        return;\n      }\n      const blot = this.scroll.find(node);\n      if (blot == null) {\n        return;\n      }\n      if (\n        blot.domNode.parentNode == null ||\n        blot.domNode.parentNode === this.domNode\n      ) {\n        blot.detach();\n      }\n    });\n    addedNodes\n      .filter((node) => {\n        return node.parentNode === this.domNode && node !== this.uiNode;\n      })\n      .sort((a, b) => {\n        if (a === b) {\n          return 0;\n        }\n        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return 1;\n        }\n        return -1;\n      })\n      .forEach((node) => {\n        let refBlot: Blot | null = null;\n        if (node.nextSibling != null) {\n          refBlot = this.scroll.find(node.nextSibling);\n        }\n        const blot = makeAttachedBlot(node, this.scroll);\n        if (blot.next !== refBlot || blot.next == null) {\n          if (blot.parent != null) {\n            blot.parent.removeChild(this);\n          }\n          this.insertBefore(blot, refBlot || undefined);\n        }\n      });\n    this.enforceAllowedChildren();\n  }\n}\n\nexport default ParentBlot;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport type {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\n\n// Shallow object comparison\nfunction isEqual(\n  obj1: Record<string, unknown>,\n  obj2: Record<string, unknown>,\n): boolean {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n  for (const prop in obj1) {\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass InlineBlot extends ParentBlot implements Formattable {\n  public static allowedChildren: BlotConstructor[] = [InlineBlot, LeafBlot];\n  public static blotName = 'inline';\n  public static scope = Scope.INLINE_BLOT;\n  public static tagName: string | string[] = 'SPAN';\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(InlineBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n    return undefined;\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach((child) => {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n        this.attributes.copy(child as InlineBlot);\n      });\n      this.unwrap();\n    } else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) {\n        return;\n      }\n      if (format instanceof Attributor) {\n        this.attributes.attribute(format, value);\n      } else if (\n        value &&\n        (name !== this.statics.blotName || this.formats()[name] !== value)\n      ) {\n        this.replaceWith(name, value);\n      }\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (\n      this.formats()[name] != null ||\n      this.scroll.query(name, Scope.ATTRIBUTE)\n    ) {\n      const blot = this.isolate(index, length) as InlineBlot;\n      blot.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n    const next = this.next;\n    if (\n      next instanceof InlineBlot &&\n      next.prev === this &&\n      isEqual(formats, next.formats())\n    ) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as InlineBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper = super.wrap(name, value);\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n    return wrapper;\n  }\n}\n\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport type { Blot, BlotConstructor, Formattable, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\nimport InlineBlot from './inline';\n\nclass BlockBlot extends ParentBlot implements Formattable {\n  public static blotName = 'block';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[] = 'P';\n  public static allowedChildren: BlotConstructor[] = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n  ];\n\n  static create(value?: unknown) {\n    return super.create(value) as HTMLElement;\n  }\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(BlockBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    if (format == null) {\n      return;\n    } else if (format instanceof Attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (\n      value &&\n      (name !== this.statics.blotName || this.formats()[name] !== value)\n    ) {\n      this.replaceWith(name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (this.scroll.query(name, Scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n      // Insert text or inline\n      super.insertAt(index, value, def);\n    } else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as BlockBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n}\n\nexport default BlockBlot;\n","import Scope from '../../scope';\nimport BlockBlot from '../block';\nimport ParentBlot from './parent';\n\nclass ContainerBlot extends ParentBlot {\n  public static blotName = 'container';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string | string[];\n\n  public prev!: BlockBlot | ContainerBlot | null;\n  public next!: BlockBlot | ContainerBlot | null;\n\n  public checkMerge(): boolean {\n    return (\n      this.next !== null && this.next.statics.blotName === this.statics.blotName\n    );\n  }\n\n  public deleteAt(index: number, length: number): void {\n    super.deleteAt(index, length);\n    this.enforceAllowedChildren();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    super.formatAt(index, length, name, value);\n    this.enforceAllowedChildren();\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    super.insertAt(index, value, def);\n    this.enforceAllowedChildren();\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n}\n\nexport default ContainerBlot;\n","import type { Formattable, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\n\nclass EmbedBlot extends LeafBlot implements Formattable {\n  public static formats(_domNode: HTMLElement, _scroll: Root): any {\n    return undefined;\n  }\n\n  public format(name: string, value: any): void {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    super.formatAt(0, this.length(), name, value);\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\n\nexport default EmbedBlot;\n","import Registry, { type RegistryDefinition } from '../registry';\nimport Scope from '../scope';\nimport type { Blot, BlotConstructor, Root } from './abstract/blot';\nimport ContainerBlot from './abstract/container';\nimport ParentBlot from './abstract/parent';\nimport BlockBlot from './block';\n\nconst OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst MAX_OPTIMIZE_ITERATIONS = 100;\n\nclass ScrollBlot extends ParentBlot implements Root {\n  public static blotName = 'scroll';\n  public static defaultChild = BlockBlot;\n  public static allowedChildren: BlotConstructor[] = [BlockBlot, ContainerBlot];\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'DIV';\n\n  public observer: MutationObserver;\n\n  constructor(\n    public registry: Registry,\n    node: HTMLDivElement,\n  ) {\n    // @ts-expect-error scroll is the root with no parent\n    super(null, node);\n    this.scroll = this;\n    this.build();\n    this.observer = new MutationObserver((mutations: MutationRecord[]) => {\n      this.update(mutations);\n    });\n    this.observer.observe(this.domNode, OBSERVER_CONFIG);\n    this.attach();\n  }\n\n  public create(input: Node | string | Scope, value?: any): Blot {\n    return this.registry.create(this, input, value);\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    const blot = this.registry.find(node, bubble);\n    if (!blot) {\n      return null;\n    }\n    if (blot.scroll === this) {\n      return blot;\n    }\n    return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): RegistryDefinition | null {\n    return this.registry.query(query, scope);\n  }\n\n  public register(...definitions: RegistryDefinition[]) {\n    return this.registry.register(...definitions);\n  }\n\n  public build(): void {\n    if (this.scroll == null) {\n      return;\n    }\n    super.build();\n  }\n\n  public detach(): void {\n    super.detach();\n    this.observer.disconnect();\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.update();\n    if (index === 0 && length === this.length()) {\n      this.children.forEach((child) => {\n        child.remove();\n      });\n    } else {\n      super.deleteAt(index, length);\n    }\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.update();\n    super.formatAt(index, length, name, value);\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    this.update();\n    super.insertAt(index, value, def);\n  }\n\n  public optimize(context?: { [key: string]: any }): void;\n  public optimize(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void;\n  public optimize(mutations: any = [], context: any = {}): void {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || new WeakMap();\n    // We must modify mutations directly, cannot make copy and then modify\n    let records = Array.from(this.observer.takeRecords());\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    const mark = (blot: Blot | null, markParent = true): void => {\n      if (blot == null || blot === this) {\n        return;\n      }\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    const optimize = (blot: Blot): void => {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n      if (blot instanceof ParentBlot) {\n        blot.children.forEach(optimize);\n      }\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n      remaining.forEach((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach((node: Node) => {\n              const child = this.find(node, false);\n              mark(child, false);\n              if (child instanceof ParentBlot) {\n                child.children.forEach((grandChild: Blot) => {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n\n  public update(\n    mutations?: MutationRecord[],\n    context: { [key: string]: any } = {},\n  ): void {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = new WeakMap();\n    mutations\n      .map((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return null;\n        }\n        if (mutationsMap.has(blot.domNode)) {\n          mutationsMap.get(blot.domNode).push(mutation);\n          return null;\n        } else {\n          mutationsMap.set(blot.domNode, [mutation]);\n          return blot;\n        }\n      })\n      .forEach((blot: Blot | null) => {\n        if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n          blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }\n      });\n    context.mutationsMap = mutationsMap;\n    if (mutationsMap.has(this.domNode)) {\n      super.update(mutationsMap.get(this.domNode), context);\n    }\n    this.optimize(mutations, context);\n  }\n}\n\nexport default ScrollBlot;\n","import Scope from '../scope';\nimport type { Blot, Leaf, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\n\nclass TextBlot extends LeafBlot implements Leaf {\n  public static readonly blotName = 'text';\n  public static scope = Scope.INLINE_BLOT;\n\n  public static create(value: string): Text {\n    return document.createTextNode(value);\n  }\n\n  public static value(domNode: Text): string {\n    return domNode.data;\n  }\n\n  public domNode!: Text;\n  protected text: string;\n\n  constructor(scroll: Root, node: Node) {\n    super(scroll, node);\n    this.text = this.statics.value(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.domNode.data = this.text =\n      this.text.slice(0, index) + this.text.slice(index + length);\n  }\n\n  public index(node: Node, offset: number): number {\n    if (this.domNode === node) {\n      return offset;\n    }\n    return -1;\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n  public length(): number {\n    return this.text.length;\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.text = this.statics.value(this.domNode);\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), (this.next as TextBlot).value());\n      this.next.remove();\n    }\n  }\n\n  public position(index: number, _inclusive = false): [Node, number] {\n    return [this.domNode, index];\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    if (\n      mutations.some((mutation) => {\n        return (\n          mutation.type === 'characterData' && mutation.target === this.domNode\n        );\n      })\n    ) {\n      this.text = this.statics.value(this.domNode);\n    }\n  }\n\n  public value(): string {\n    return this.text;\n  }\n}\n\nexport default TextBlot;\n"],"names":["Scope","Attributor","attrName","keyName","options","attributeBit","node","item","value","_node","ParchmentError","message","_Registry","bubble","parentNode","scroll","input","match","blotClass","blot","query","scope","name","definitions","definition","isBlot","isAttr","key","tagName","tag","Registry","prefix","ClassAttributor","camelize","parts","rest","part","StyleAttributor","AttributorStore","domNode","attribute","attributes","classes","styles","attr","target","_ShadowBlot","rawValue","index","length","parent","def","ref","root","_context","replacement","_force","_mutations","wrapper","ShadowBlot","_LeafBlot","_domNode","offset","_inclusive","LeafBlot","LinkedList","nodes","next","cur","refNode","curNode","ret","inclusive","callback","startNode","curIndex","curLength","memo","makeAttachedBlot","found","child","_ParentBlot","other","err","childLength","criteria","descendants","lengthLeft","childIndex","done","childBlot","refBlot","refDomNode","targetParent","context","position","force","after","_length","split","mutations","addedNodes","removedNodes","mutation","a","b","ParentBlot","isEqual","obj1","obj2","prop","_InlineBlot","format","formats","InlineBlot","_BlockBlot","BlockBlot","_ContainerBlot","ContainerBlot","EmbedBlot","_scroll","OBSERVER_CONFIG","MAX_OPTIMIZE_ITERATIONS","_ScrollBlot","registry","mutationsMap","records","mark","markParent","optimize","remaining","i","grandChild","ScrollBlot","_TextBlot","TextBlot"],"mappings":"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"}